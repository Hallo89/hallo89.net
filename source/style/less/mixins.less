// main: global.less|main.less|slider89/index.less

.noselect() {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

#for(@end-inclusive, @rule) {
  each(range(@end-inclusive), @rule);
}

.selection(@color; @background: transparent;) {
  &::selection, &::-moz-selection {
    background-color: @background;
    color: @color;
  }
}

.mode-transition() {
  .background() {
    transition+: background .15s linear;
  }
  .shadow() {
    transition+: box-shadow .15s linear;
  }
  .color() {
    transition+: color .15s linear;
  }
  .textshadow() {
    transition+: text-shadow .15s linear;
  }
  .border() {
    transition+: border .15s linear;
  }
}

.boxanimation(@seconds) {
  animation: @seconds shiftinBox ease-out;
}

.drop-shadow(@amount, @color, @it: 0) {
  & when not (@it = 0) {
    text-shadow+: unit(@it, px) unit(@it, px) @color;
  }
  & when (@it < @amount) {
    text-shadow+: @it + .5px @it + .5px @color;
    .drop-shadow(@amount, @color, @it + 1);
  }
}

.wave() {
  #animation(@it) {
    // this is a root function to approximate an ease-in
    animation: .37s .13s * pow(@it, 1 / 1.375) textWave ease;
  }

  .generate-targets(@textlen, @class) {
    each(range(@textlen), {
      &.@{class}@{index} span {
        .wave.target(@textlen, @index);
      }
    });
  }
  .target(@textlen, @target, @it: 0) {
    @half: ceil(@textlen / 2);
    & when (@it < abs(@target - @half) + @half) {
      @next: @target + @it;
      @prev: @target - @it;
      & when (@prev > 0) and (@next <= @textlen) and not (@next = @prev) {
        &:nth-child(@{next}),
        &:nth-child(@{prev}) {
          .wave#animation(@it);
        }
      }
      & when not (@prev > 0) or (@next = @prev) {
        &:nth-child(@{next}) {
          .wave#animation(@it);
        }
      }
      & when not (@next <= @textlen) {
        &:nth-child(@{prev}) {
          .wave#animation(@it);
        }
      }
      .wave.target(@textlen, @target, @it + 1);
    }
  }
}
